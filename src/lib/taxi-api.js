import express from 'express'; import { createServer } from 'http'; import { Server } from 'socket.io'; import path from 'path'; import cors from 'cors'; import { fileURLToPath } from 'url'; import fs from 'fs'; import crypto from 'crypto'; import { readGlobalStore, writeGlobalStore, upsertUserToGlobal, upsertProfileToGlobal, appendOrderToGlobal, updateOrderInGlobal, appendMessageToGlobal } from './globalStore.js';  const __filename = fileURLToPath(import.meta.url); const __dirname = path.dirname(__filename);  import 'dotenv/config'; import Airtable from 'airtable'; const airtable = new Airtable({ apiKey: process.env.AIRTABLE_PAT }).base(process.env.AIRTABLE_BASE_ID); const app = express();  // Health endpoint // Health endpoint (with Airtable driver stats) app.get('/api/health', async (req, res) => {   try {     let stats = null;     try {       const all = await airtable('Drivers').select().all();       const total = all.length;       const idle = all.filter(d => (d.fields.status || '').toLowerCase() === 'available').length;       const busy = all.filter(d => (d.fields.status || '').toLowerCase() === 'on_trip').length;       const offline = all.filter(d => (d.fields.status || '').toLowerCase() === 'offline').length;       stats = { total, idle, busy, offline };     } catch (_) {       // Airtable ???,????????       stats = null;     }     res.json({ status: 'ok', data: stats });   } catch (err) {     res.status(500).json({ status: 'error', error: err?.message || 'unknown error' });   } }); const server = createServer(app); // Airtable ?????? async function autoDispatchOrder(orderId) {   const drivers = await airtable('Drivers').select({ filterByFormula: "{status}='available'" }).all();   if (!drivers || drivers.length === 0) {     console.log('auto-dispatch: assigned a driver');     return;   }   const driver = drivers[0];   await airtable('Orders').update([     { id: orderId, fields: { driver_id: driver.id, status: 'assigned' } }   ]);   await airtable('Drivers').update([     { id: driver.id, fields: { status: 'on_trip' } }   ]);   console.log('auto-dispatch: assigned a driver'); }  // ????????? app.post('/api/order', async (req, res) => {   try {     const record = await airtable('Orders').create([{ fields: req.body }]);     const newOrder = record[0];     autoDispatchOrder(newOrder.id);     res.json({ success: true, order: newOrder });   } catch (e) {     console.error('create order error', e);     res.status(500).json({ error: e.message });   } }); const io = new Server(server, {   cors: {     origin: "*",     methods: ["GET", "POST"]   } });  const PORT = process.env.PORT || 3001; const DATA_DIR = path.join(__dirname, 'data', 'accounts'); const LOG_DIR = path.join(__dirname, 'data', 'logs');  // ç¢ºä¿æ⬢¸æ�Sšç⬺®é��~å­�Så�¨ // æ¸⬦ç⬠ï¼šä¸å⬠é å⬦� å»ºç«⬹æ¨¡æ�S¬å¸³è��Ÿè³⬡æ���å¤¾ï¼⬺è⬹¥ä¸å­�Så�¨å⬰⬡ç¶­æ�ç©ºè³⬡æ���å¤¾ä»¥å⬦è®��å¯«é�¯èª¤ if (!fs.existsSync(DATA_DIR)) {   fs.mkdirSync(DATA_DIR, { recursive: true }); } if (!fs.existsSync(LOG_DIR)) {   fs.mkdirSync(LOG_DIR, { recursive: true }); }  app.use(express.json()); app.use(express.static(path.join(__dirname, '../dist')));  // CORS ä¸­é��Sä»¶ app.use((req, res, next) => {   res.header('Access-Control-Allow-Origin', '*');   res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');   res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');      if (req.method === 'OPTIONS') {     res.sendStatus(200);   } else {     next();   } });  // å·¥å⬦·å⬡½æ⬢¸ function getUserDataPath(phone, file) {   const userDir = path.join(DATA_DIR, phone);   if (!fs.existsSync(userDir)) {     fs.mkdirSync(userDir, { recursive: true });   }   return path.join(userDir, file); }  function readUserData(phone, file, defaultData = {}) {   try {     const filePath = getUserDataPath(phone, file);     if (fs.existsSync(filePath)) {       const data = fs.readFileSync(filePath, 'utf8');       return JSON.parse(data);     }     return defaultData;   } catch (error) {     console.error('create order error', e);     return defaultData;   } }  function writeUserData(phone, file, data) {   try {     const filePath = getUserDataPath(phone, file);     fs.writeFileSync(filePath, JSON.stringify(data, null, 2), 'utf8');     return true;   } catch (error) {     console.error('create order error', e);     return false;   } }  // 伺�S��"�端���R��`� function appendServerLog(type, payload) {   try {     const filePath = path.join(LOG_DIR, 'server-logs.json');     const arr = fs.existsSync(filePath) ? JSON.parse(fs.readFileSync(filePath, 'utf8')) : [];     const item = { id: crypto.randomUUID ? crypto.randomUUID() : (Date.now() + '_' + Math.random().toString(36).slice(2)), type, payload, ts: new Date().toISOString() };     arr.push(item);     fs.writeFileSync(filePath, JSON.stringify(arr, null, 2), 'utf8');     return item;   } catch (e) {     console.warn('寫�&�伺�S��"����R失�"', e);     return null;   } }  // OTP/é©�è­⬰ç⬺¸é��å·¥å⬦· function generateOtpCode() {   return Math.floor(100000 + Math.random() * 900000).toString(); // 6ä½æ⬢¸ }  function readAuthState(phone) {   return readUserData(phone, 'auth.json', { isVerified: false, lastVerifiedAt: null }); }  function writeAuthState(phone, state) {   return writeUserData(phone, 'auth.json', state); }  function readOtpState(phone) {   return readUserData(phone, 'otp.json', null); }  function writeOtpState(phone, otp) {   return writeUserData(phone, 'otp.json', otp); }  function removeOtpState(phone) {   const filePath = getUserDataPath(phone, 'otp.json');   try {     if (fs.existsSync(filePath)) fs.unlinkSync(filePath);   } catch (e) {     console.warn('ç§»é��¤ OTP æª⬝æ¡� å¤±æ⬢�', e);   } }  function getAllDrivers() {   try {     if (!fs.existsSync(DATA_DIR)) {       return [];     }          const users = fs.readdirSync(DATA_DIR);     const drivers = [];          users.forEach(phone => {       const profile = readUserData(phone, 'profile.json', {});       if (profile.role === 'driver') {         drivers.push({           phone,           ...profile,           status: profile.status || 'offline'         });       }     });          return drivers;   } catch (error) {     console.error('create order error', e);     return [];   } }  function findAvailableDriver() {   const drivers = getAllDrivers();   // �! 'online' ��! 'idle' 钽���可派遣�9��&9   return drivers.find(driver => driver && ['idle', 'online'].includes(driver.status)); }  function generateOrderId() {   return 'ORDER_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9); }  // API è·¯ç⬝±  // ç��¼é��/é⬡å¯�~ OTPï¼� æ�¬å�°é�⬹ç��¼å¾�æ´ï¼⬰ app.post('/auth/send-otp', (req, res) => {   try {     const { phone, name, role } = req.body || {};     if (!phone) {       return res.status(400).json({ success: false, message: 'ç¼ºå°��å¿⬦è¦å�æ⬢¸ï¼šphone' });     }      // å»ºç«⬹/æ⬺´æ�°ä½¿ç⬝¨è��⬦åŸºæ�¬è³⬡æ���     const profile = readUserData(phone, 'profile.json', {});     const newProfile = {       ...profile,       phone,       name: name || profile.name || `ç⬝¨æ� ¶_${phone}`,       role: role || profile.role || 'passenger',       status: profile.status || (role === 'driver' ? 'online' : 'idle')     };     writeUserData(phone, 'profile.json', newProfile);      // é⬡ç½®é©�è­⬰ç⬹��æ⬦⬹     writeAuthState(phone, { isVerified: false, lastVerifiedAt: null });      // å»ºç«⬹ OTP     const code = generateOtpCode();     const ttlMinutes = 10;     const expiresAt = Date.now() + ttlMinutes * 60 * 1000;     writeOtpState(phone, { code, expiresAt });      console.log(`æ�¬å�° send-otp: ${phone} -> ${code} (æ�⬰æ⬢�  ${ttlMinutes} å� ⬠é�S)`);     return res.json({ success: true, data: { phone, expiresAt, ttlMinutes, devCode: code }, message: 'é©�è­⬰ç¢¼å·²ç��¼é��ï¼� æ�¬å�°é�⬹ç��¼ï¼⬰' });   } catch (error) {     console.error('create order error', e);     return res.status(500).json({ success: false, message: 'ä¼ºæ�å��¨é�¯èª¤' });   } });  // é©�è­⬰æ⬰⬹æ©Ÿï¼� æ�¬å�°é�⬹ç��¼å¾�æ´ï¼⬰ app.post('/auth/verify-phone', (req, res) => {   try {     const { phone, verificationCode } = req.body || {};     if (!phone || !verificationCode) {       return res.status(400).json({ success: false, message: 'ç¼ºå°��å¿⬦è¦å�æ⬢¸ï¼šphone, verificationCode' });     }      const otp = readOtpState(phone);     if (!otp) {       return res.status(404).json({ success: false, message: 'æ�ªæ⬰¾å� °é©�è­⬰ç¢¼ï¼�è«⬹å⬦� ç��¼é�� OTP' });     }     if (Date.now() > otp.expiresAt) {       removeOtpState(phone);       return res.status(400).json({ success: false, message: 'é©�è­⬰ç¢¼å·²éŽæ�Ÿï¼�è«⬹é⬡æ�°ç��¼é��' });     }     if (String(verificationCode) !== String(otp.code)) {       return res.status(400).json({ success: false, message: 'é©�è­⬰ç¢¼é�¯èª¤' });     }      // æ¨��è¨�Sç�aºå·²é©�è­⬰     writeAuthState(phone, { isVerified: true, lastVerifiedAt: new Date().toISOString() });     removeOtpState(phone);     console.log('auto-dispatch: assigned a driver');     return res.json({ success: true, data: { phone, verified: true }, message: 'æ⬰⬹æ©Ÿé©�è­⬰æ� åŠŸï¼� æ�¬å�°é�⬹ç��¼ï¼⬰' });   } catch (error) {     console.error('create order error', e);     return res.status(500).json({ success: false, message: 'ä¼ºæ�å��¨é�¯èª¤' });   } });  // 使�� Firebase �R�Ɛ OTP �R�a�"��端�~��不檢�x��S��S� OTP�R�&�"���a�}�0 app.post('/auth/verify-firebase', (req, res) => {   try {     const { phone } = req.body || {};     if (!phone) {       return res.status(400).json({ success: false, message: '缺��&要叒�"��aphone' });     }      // �"����已��0     writeAuthState(phone, { isVerified: true, lastVerifiedAt: new Date().toISOString() });     console.log('auto-dispatch: assigned a driver');     return res.json({ success: true, data: { phone, verified: true }, message: '�09�x��0�Ɛ�`x��Firebase�0' });   } catch (error) {     console.error('create order error', e);     return res.status(500).json({ success: false, message: '伺�S��"��R�誤' });   } });  // å«è»Šè� ⬡è⬡ªå⬹⬢æ´¾è»Š async function createRideHandler(req, res) {   try {     // �R端 Supabase URL 檢�x���!�"援提示���&���R�R不�ܻ�9�0     const {       passengerPhone,       pickup,       dropoff,       pickup_lat,       pickup_lng,       dropoff_lat,       dropoff_lng,       estimated_distance_meters,       estimated_duration_seconds,       estimated_price,       service_type,       deposit,       notes     } = req.body;          if (!passengerPhone || !pickup || !dropoff) {       return res.status(400).json({          success: false,          message: '�9確認�`�`��!�9�`�S��~已輸�&�'        });     }      // æŸ¥æ⬰¾å¯ç⬝¨å¸æ©Ÿ     const availableDriver = findAvailableDriver();          if (!availableDriver) {       return res.status(404).json({          success: false,          message: 'ç⬺®å⬰æ²�"æ�⬰å¯ç⬝¨å¸æ©Ÿ'        });     }      // ç⬝Ÿæ� è¨�aå�®     const orderId = generateOrderId();     // ��咹���9��0�端�S�提�: estimated_price�R�0!以簡���&�式����0     let price = Number(estimated_price);     if (!price || Number.isNaN(price)) {       const km = (Number(estimated_distance_meters) || 0) / 1000;       const minutes = (Number(estimated_duration_seconds) || 0) / 60;       const base = 70;       const perKm = 15;       const perMin = 3;       const longTripExtra = km > 20 ? (km - 20) * 10 : 0;       price = Math.round(base + km * perKm + minutes * perMin + longTripExtra);     }      const order = {       id: orderId,       passengerPhone,       driverPhone: availableDriver.phone,       driverName: availableDriver.name,       pickup,       dropoff,       status: 'pending',       createdAt: new Date().toISOString(),       estimatedPrice: price,       pickup_lat,       pickup_lng,       dropoff_lat,       dropoff_lng,       estimated_distance_meters,       estimated_duration_seconds,       service_type: service_type || 'standard',       deposit: Number(deposit) || 0,       notes: notes || ''     };      // æ⬺´æ�°å¸æ©Ÿç⬹��æ⬦⬹ç�aºå¿��ç¢�     const driverProfile = readUserData(availableDriver.phone, 'profile.json', {});     driverProfile.status = 'busy';     writeUserData(availableDriver.phone, 'profile.json', driverProfile);      // ä¿å­�Sè¨�aå�®å� °å¸æ©Ÿå�"�ä¹�Så®¢çš�~è¨�Sé��~     const driverOrders = readUserData(availableDriver.phone, 'orders.json', []);     driverOrders.push(order);     writeUserData(availableDriver.phone, 'orders.json', driverOrders);      const passengerOrders = readUserData(passengerPhone, 'orders.json', []);     passengerOrders.push(order);     writeUserData(passengerPhone, 'orders.json', passengerOrders);      // é��šçŸ¥æ⬰��æ�⬰é��£æŽ¥çš�~å®¢æ� ¶ç«¯     io.emit('order_created', order);     io.emit('driver_status_update', {        phone: availableDriver.phone,        status: 'busy'      });      console.log('auto-dispatch: assigned a driver');      // ���R���R     appendServerLog('ride_request_success', { order, driver: availableDriver });      // 寫�&��&��xx�����global.json�0     try { appendOrderToGlobal(order); } catch (_) {}      res.json({        success: true,        order,       driver: availableDriver,       message: 'å«è»Šæ� åŠŸï¼�å¸æ©Ÿå·²å� ⬠é⬦'      });    } catch (error) {     console.error('create order error', e);     appendServerLog('ride_request_error', { error: String(error && error.stack || error) });     res.status(500).json({        success: false,        message: 'ä¼ºæ�å��¨é�¯èª¤'      });   } }  // 主路�� app.post('/ride/request', async (req, res) => {   return createRideHandler(req, res); });  // �:�容�ƥ名��依使���&�S���0�a/api/book㬁/api/create_ride app.post('/api/book', async (req, res) => {   return createRideHandler(req, res); }); app.post('/api/create_ride', async (req, res) => {   return createRideHandler(req, res); });  // ���~�ƥ名�a/create_order����! createRideHandler �:��R�0 app.post('/create_order', async (req, res) => {   return createRideHandler(req, res); });  // 客�ƶ端�R�誤���R app.post('/logs/client-error', (req, res) => {   try {     const { userId, message, context } = req.body || {};     const item = appendServerLog('client_error', { userId, message, context });     return res.json({ success: true, item });   } catch (e) {     return res.status(500).json({ success: false, message: '伺�S��"��R�誤' });   } });  // å®�æ� è¨�aå�® app.post('/ride/complete', async (req, res) => {   try {     const { orderId, driverPhone } = req.body;          if (!orderId || !driverPhone) {       return res.status(400).json({          success: false,          message: 'ç¼ºå°��å¿⬦è¦å�æ⬢¸ï¼šorderId, driverPhone'        });     }      // ç²å�å¸æ©Ÿè¨�aå�®     const driverOrders = readUserData(driverPhone, 'orders.json', []);     const orderIndex = driverOrders.findIndex(order => order.id === orderId);          if (orderIndex === -1) {       return res.status(404).json({          success: false,          message: 'æ⬰¾ä¸å� °è©²è¨�aå�®'        });     }      // æ⬺´æ�°è¨�aå�®ç⬹��æ⬦⬹     driverOrders[orderIndex].status = 'completed';     driverOrders[orderIndex].completedAt = new Date().toISOString();     writeUserData(driverPhone, 'orders.json', driverOrders);      // æ⬺´æ�°ä¹�Så®¢è¨�aå�®     const passengerPhone = driverOrders[orderIndex].passengerPhone;     const passengerOrders = readUserData(passengerPhone, 'orders.json', []);     const passengerOrderIndex = passengerOrders.findIndex(order => order.id === orderId);     if (passengerOrderIndex !== -1) {       passengerOrders[passengerOrderIndex].status = 'completed';       passengerOrders[passengerOrderIndex].completedAt = new Date().toISOString();       writeUserData(passengerPhone, 'orders.json', passengerOrders);     }      // æ¢å¾©å¸æ©Ÿç⬹��æ⬦⬹ç�aºé��"ç½®     const driverProfile = readUserData(driverPhone, 'profile.json', {});     driverProfile.status = 'idle';     writeUserData(driverPhone, 'profile.json', driverProfile);      // é��šçŸ¥æ⬰��æ�⬰é��£æŽ¥çš�~å®¢æ� ¶ç«¯     io.emit('order_completed', driverOrders[orderIndex]);     io.emit('driver_status_update', {        phone: driverPhone,        status: 'idle'      });      console.log('auto-dispatch: assigned a driver');      // �&��xx����9��&9�R步     try { updateOrderInGlobal(orderId, { status: 'completed', completed_at: new Date().toISOString() }); } catch (_) {}      res.json({        success: true,        order: driverOrders[orderIndex],       message: 'è¨�aå�®å·²å®�æ� '      });    } catch (error) {     console.error('create order error', e);     res.status(500).json({        success: false,        message: 'ä¼ºæ�å��¨é�¯èª¤'      });   } });  // é��šç⬝¨è¨�aå�®ç⬹��æ⬦⬹æ⬺´æ�°ï¼� accepted/enroute/arrived/completed/cancelled ç­⬰ï¼⬰ app.post('/ride/update-status', async (req, res) => {   try {     let { orderId, driverPhone, passengerPhone, nextStatus } = req.body;     if (!orderId || !nextStatus) {       return res.status(400).json({ success: false, message: 'ç¼ºå°��å¿⬦è¦å�æ⬢¸ï¼šorderId, nextStatus' });     }      // å�~ªå⬦� å�¨æä¾⬺çš�~ç«¯æª¢ç´¢è¨�aå�®     let order = null;     let driverOrders = [];     let passengerOrders = [];      if (driverPhone) {       driverOrders = readUserData(driverPhone, 'orders.json', []);       order = driverOrders.find(o => o.id === orderId) || null;     }     if (!order && passengerPhone) {       passengerOrders = readUserData(passengerPhone, 'orders.json', []);       order = passengerOrders.find(o => o.id === orderId) || null;     }      // æ�ªæ�⬡å®šäº¦æ�ªæ⬰¾å� °æ���aï¼�æŽ�æå⬦¨é�¨å¸³è��Ÿè³⬡æ���å¤¾     if (!order) {       try {         const users = fs.existsSync(DATA_DIR) ? fs.readdirSync(DATA_DIR) : [];         for (const phone of users) {           const orders = readUserData(phone, 'orders.json', []);           const found = orders.find(o => o.id === orderId);           if (found) {             order = found;             driverPhone = found.driverPhone;             passengerPhone = found.passengerPhone;             driverOrders = readUserData(driverPhone, 'orders.json', []);             passengerOrders = readUserData(passengerPhone, 'orders.json', []);             break;           }         }       } catch (_) {}     }      if (!order) {       return res.status(404).json({ success: false, message: 'æ⬰¾ä¸å� °è©²è¨�aå�®' });     }      const now = new Date().toISOString();     const updater = (o) => {       if (o.id !== orderId) return o;       const updated = { ...o, status: nextStatus };       if (nextStatus === 'completed') updated.completedAt = now;       return updated;     };      if (driverPhone) {       driverOrders = driverOrders.length ? driverOrders : readUserData(driverPhone, 'orders.json', []);       driverOrders = driverOrders.map(updater);       writeUserData(driverPhone, 'orders.json', driverOrders);     }     if (passengerPhone) {       passengerOrders = passengerOrders.length ? passengerOrders : readUserData(passengerPhone, 'orders.json', []);       passengerOrders = passengerOrders.map(updater);       writeUserData(passengerPhone, 'orders.json', passengerOrders);     }      // å�æ­¥å¸æ©Ÿç⬹��æ⬦⬹     const driverId = driverPhone || order.driverPhone;     if (driverId) {       const profile = readUserData(driverId, 'profile.json', {});       if (nextStatus === 'completed' || nextStatus === 'cancelled') {         profile.status = 'idle';       } else if (nextStatus === 'accepted' || nextStatus === 'enroute' || nextStatus === 'arrived') {         profile.status = 'busy';       }       writeUserData(driverId, 'profile.json', profile);       io.emit('driver_status_update', { phone: driverId, status: profile.status });     }      const updatedOrder = (driverPhone ? driverOrders : passengerOrders).find(o => o.id === orderId) || order;     io.emit('order_status_update', updatedOrder);      // �&��xx����9��&9�R步     try {       const patch = { status: nextStatus };       if (nextStatus === 'completed') patch.completed_at = new Date().toISOString();       updateOrderInGlobal(orderId, patch);     } catch (_) {}      return res.json({ success: true, order: updatedOrder, message: 'è¨�aå�®ç⬹��æ⬦⬹å·²æ⬺´æ�°' });   } catch (error) {     console.error('create order error', e);     res.status(500).json({ success: false, message: 'ä¼ºæ�å��¨é�¯èª¤' });   } });  // ç²å�å¸æ©Ÿç⬹��æ⬦⬹ app.get('/drivers/status', (req, res) => {   try {     const drivers = getAllDrivers();          const statusSummary = {       total: drivers.length,       idle: drivers.filter(d => d.status === 'idle').length,       busy: drivers.filter(d => d.status === 'busy').length,       offline: drivers.filter(d => d.status === 'offline').length,       drivers: drivers.map(driver => ({         phone: driver.phone,         name: driver.name,         status: driver.status,         vehicle: driver.vehicle,         lat: (driver.location && driver.location.lat) || driver.lat || null,         lng: (driver.location && driver.location.lng) || driver.lng || null       }))     };      res.json({        success: true,        data: statusSummary      });    } catch (error) {     console.error('create order error', e);     res.status(500).json({        success: false,        message: 'ä¼ºæ�å��¨é�¯èª¤'      });   } });  // ç²å�ç⬝¨æ� ¶è³⬡æ��� app.get('/user/:phone', (req, res) => {   try {     const { phone } = req.params;     const profile = readUserData(phone, 'profile.json', null);          if (!profile) {       return res.status(404).json({          success: false,          message: 'ç⬝¨æ� ¶ä¸å­�Så�¨'        });     }      res.json({        success: true,        data: profile      });    } catch (error) {     console.error('create order error', e);     res.status(500).json({        success: false,        message: 'ä¼ºæ�å��¨é�¯èª¤'      });   } });  // ç²å�ç⬝¨æ� ¶è¨�aå�® app.get('/user/:phone/orders', (req, res) => {   try {     const { phone } = req.params;     const orders = readUserData(phone, 'orders.json', []);          res.json({        success: true,        data: orders.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))      });    } catch (error) {     console.error('create order error', e);     res.status(500).json({        success: false,        message: 'ä¼ºæ�å��¨é�¯èª¤'      });   } });  // æ⬺´æ�°å¸æ©Ÿç⬹��æ⬦⬹ app.post('/driver/:phone/status', (req, res) => {   try {     const { phone } = req.params;     const { status } = req.body;          if (!['idle', 'busy', 'offline'].includes(status)) {       return res.status(400).json({          success: false,          message: 'ç�~¡æ⬢� çš�~ç⬹��æ⬦⬹å��¼'        });     }      const profile = readUserData(phone, 'profile.json', {});     profile.status = status;          if (writeUserData(phone, 'profile.json', profile)) {       io.emit('driver_status_update', { phone, status });              res.json({          success: true,          message: 'ç⬹��æ⬦⬹æ⬺´æ�°æ� åŠŸ'        });     } else {       res.status(500).json({          success: false,          message: 'ç⬹��æ⬦⬹æ⬺´æ�°å¤±æ⬢�'        });     }    } catch (error) {     console.error('create order error', e);     res.status(500).json({        success: false,        message: 'ä¼ºæ�å��¨é�¯èª¤'      });   } });  // 司�x忒跳��位置��!�9��&9�:����0 app.post('/driver-heartbeat', (req, res) => {   try {     const { phone, status, lat, lng } = req.body || {};     if (!phone) {       return res.status(400).json({ success: false, message: '缺��&要叒�"��aphone' });     }      const profile = readUserData(phone, 'profile.json', {});     profile.phone = String(phone);     if (!profile.role) profile.role = 'driver';     if (status && ['idle','busy','offline','online'].includes(String(status))) {       // �9��0�端�� online�R��� idle 可派遣       profile.status = (status === 'online') ? 'idle' : String(status);     }     if (lat !== undefined && lng !== undefined) {       profile.location = { lat: Number(lat), lng: Number(lng), ts: new Date().toISOString() };     }     writeUserData(phone, 'profile.json', profile);      // �&��xx����R步     try {       upsertProfileToGlobal({         user_id: String(phone),         vehicle_info: profile.vehicle || profile.car_plate || null,         rating_avg: profile.rating_avg || null,         total_orders: profile.total_orders || 0,         current_status: profile.status || 'idle',         location: profile.location || null       });     } catch (_) {}      io.emit('driver_status_update', { phone: String(phone), status: profile.status, location: profile.location });     return res.json({ success: true, data: { phone: String(phone), status: profile.status, location: profile.location } });   } catch (error) {     console.error('create order error', e);     return res.status(500).json({ success: false, message: '伺�S��"��R�誤' });   } });  // ����"咹���R�Ɛ�R�0 // POST /orders/review { orderId, rating(1-5), comment?, by_phone } app.post('/orders/review', (req, res) => {   try {     const { orderId, rating, comment, by_phone } = req.body || {};     if (!orderId || rating === undefined) {       return res.status(400).json({ success: false, message: '缺��&要叒�"��aorderId, rating' });     }     const score = Number(rating);     if (!(score >= 1 && score <= 5)) {       return res.status(400).json({ success: false, message: 'rating �&���S� 1~5 �9�' });     }      // �9�0�������&���試�&��xx�R�R�"�!��S��S�����0     let order = null;     const store = readGlobalStore();     order = store.orders.find(o => String(o.id) === String(orderId)) || null;     let driverPhone = null;     let passengerPhone = null;      if (!order) {       const users = fs.existsSync(DATA_DIR) ? fs.readdirSync(DATA_DIR) : [];       for (const phone of users) {         const orders = readUserData(phone, 'orders.json', []);         const found = orders.find(o => o.id === orderId);         if (found) {           order = found;           driverPhone = found.driverPhone;           passengerPhone = found.passengerPhone;           break;         }       }     } else {       driverPhone = order.driver_id || order.driverPhone || null;       passengerPhone = order.passenger_id || order.passengerPhone || null;     }      if (!order) {       return res.status(404).json({ success: false, message: '�0�不�ư該���' });     }      const review = { rating: score, comment: String(comment || ''), by: by_phone || null, at: new Date().toISOString() };      // �:����S��S� orders.json��司�x��!��客�0     if (driverPhone) {       const dOrders = readUserData(driverPhone, 'orders.json', []);       const dIdx = dOrders.findIndex(o => o.id === orderId);       if (dIdx >= 0) { dOrders[dIdx].review = review; writeUserData(driverPhone, 'orders.json', dOrders); }     }     if (passengerPhone) {       const pOrders = readUserData(passengerPhone, 'orders.json', []);       const pIdx = pOrders.findIndex(o => o.id === orderId);       if (pIdx >= 0) { pOrders[pIdx].review = review; writeUserData(passengerPhone, 'orders.json', pOrders); }     }      // �:����&��xx���     try { updateOrderInGlobal(orderId, { review }); } catch (_) {}      // �:���司�x�"��      if (driverPhone) {       const dProfile = readUserData(driverPhone, 'profile.json', {});       const prevAvg = Number(dProfile.rating_avg || 0);       const prevCount = Number(dProfile.review_count || 0);       const newCount = prevCount + 1;       const newAvg = newCount > 0 ? ((prevAvg * prevCount + score) / newCount) : score;       dProfile.rating_avg = Math.round(newAvg * 100) / 100;       dProfile.review_count = newCount;       writeUserData(driverPhone, 'profile.json', dProfile);       // �&��xx����R步       try { upsertProfileToGlobal({ user_id: String(driverPhone), rating_avg: dProfile.rating_avg, total_orders: dProfile.total_orders || 0, current_status: dProfile.status || 'idle', location: dProfile.location || null }); } catch (_) {}     }      io.emit('order_review_update', { orderId, review });     return res.json({ success: true, data: { orderId, review }, message: '�"咹已鬁�!�' });   } catch (error) {     console.error('create order error', e);     return res.status(500).json({ success: false, message: '伺�S��"��R�誤' });   } });  // �"�鬁�`息����客� 司�x� �R台�0 // POST /messages/send { from, to, content, orderId? } app.post('/messages/send', (req, res) => {   try {     const { from, to, content, orderId } = req.body || {};     if (!from || !to || !content) {       return res.status(400).json({ success: false, message: '缺��&要叒�"��afrom, to, content' });     }     const msg = appendMessageToGlobal({ from_user_id: String(from), to_user_id: String(to), content: String(content), order_id: orderId || null });     io.emit('message_sent', msg);     return res.json({ success: true, data: msg });   } catch (error) {     console.error('create order error', e);     return res.status(500).json({ success: false, message: '伺�S��"��R�誤' });   } });  // �`息歷史 // GET /messages/history?userA=xxx&userB=yyy&orderId=opt app.get('/messages/history', (req, res) => {   try {     const { userA, userB, orderId } = req.query || {};     const store = readGlobalStore();     let msgs = store.messages || [];     if (orderId) {       msgs = msgs.filter(m => String(m.order_id || '') === String(orderId));     }     if (userA && userB) {       msgs = msgs.filter(m => (String(m.from_user_id) === String(userA) && String(m.to_user_id) === String(userB)) || (String(m.from_user_id) === String(userB) && String(m.to_user_id) === String(userA)));     }     msgs = msgs.sort((a,b) => new Date(a.created_at) - new Date(b.created_at));     return res.json({ success: true, data: msgs });   } catch (error) {     console.error('create order error', e);     return res.status(500).json({ success: false, message: '伺�S��"��R�誤' });   } });  // 管� ���x��S9伺�S��"����R app.get('/admin/logs', (req, res) => {   try {     const filePath = path.join(LOG_DIR, 'server-logs.json');     const logs = fs.existsSync(filePath) ? JSON.parse(fs.readFileSync(filePath, 'utf8')) : [];     return res.json({ success: true, data: logs });   } catch (error) {     console.error('create order error', e);     return res.status(500).json({ success: false, message: '伺�S��"��R�誤' });   } });  // ç²å�æ⬰��æ�⬰è¨�aå�®ï¼� ç®¡ç⬠å�S¡ï¼⬰ app.get('/orders/all', (req, res) => {   try {     // ���&�使���&��xx�����global.json�0     const globalStore = readGlobalStore();     if (globalStore.orders && globalStore.orders.length) {       const sorted = [...globalStore.orders].sort((a, b) => new Date(b.created_at || b.createdAt || 0) - new Date(a.created_at || a.createdAt || 0));       return res.json({ success: true, data: sorted });     }      if (!fs.existsSync(DATA_DIR)) {       return res.json({ success: true, data: [] });     }          const allOrders = [];     const users = fs.readdirSync(DATA_DIR);          users.forEach(phone => {       const orders = readUserData(phone, 'orders.json', []);       allOrders.push(...orders);     });      // åŽ»é⬡ä¸¦æ�⬰æ���aé��SæŽ�"åº     const uniqueOrders = allOrders.filter((order, index, self) =>        index === self.findIndex(o => o.id === order.id)     ).sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));      res.json({        success: true,        data: uniqueOrders      });    } catch (error) {     console.error('create order error', e);     res.status(500).json({        success: false,        message: 'ä¼ºæ�å��¨é�¯èª¤'      });   } });  // WebSocket é��£æŽ¥è��⬢ç⬠ io.on('connection', (socket) => {   console.log('auto-dispatch: assigned a driver');      socket.on('join_room', (room) => {     socket.join(room);     console.log('auto-dispatch: assigned a driver');   });      socket.on('disconnect', () => {     console.log('auto-dispatch: assigned a driver');   }); });  // æä¾⬺å⬰ç«¯é é¢ // Password-based registration (local development) // POST /auth/register { phone, password, name?, role? (passenger|driver|admin), nickname?, car_plate?, remember? } app.post('/auth/register', (req, res) => {   try {     const { phone, password, name, role = 'passenger', nickname, car_plate, remember } = req.body || {};     if (!phone || !password) {       return res.status(400).json({ success: false, message: '缺��&要�位�aphone, password' });     }      // prevent re-register     const authPath = getUserDataPath(phone, 'auth.json');     if (fs.existsSync(authPath)) {       return res.status(409).json({ success: false, message: '此�"x碼已註� `' });     }      // additional duplication checks (global store / existing profile file)     try {       const store = readGlobalStore();       const existsInUsers = Array.isArray(store.users) && store.users.some(u => String(u.phone) === String(phone));       const existsInProfiles = Array.isArray(store.profiles) && store.profiles.some(p => String(p.user_id) === String(phone));       const profilePath = getUserDataPath(phone, 'profile.json');       if (existsInUsers || existsInProfiles || fs.existsSync(profilePath)) {         return res.status(409).json({ success: false, message: '此�"x碼已註� `' });       }     } catch (_) {}      // hash password     const salt = crypto.randomBytes(16).toString('hex');     const hash = crypto.pbkdf2Sync(String(password), salt, 100000, 64, 'sha512').toString('hex');     writeUserData(phone, 'auth.json', { salt, hash, createdAt: new Date().toISOString() });      // prepare profile     const finalRole = ['passenger','driver','admin'].includes(String(role)) ? String(role) : 'passenger';     const finalName = name && String(name).trim().length > 0 ? String(name).trim() : `User_${phone}`;     const status = finalRole === 'driver' ? 'online' : 'idle';     const profile = { phone, name: finalName, role: finalRole, status };     if (finalRole === 'driver') {       if (nickname) profile.nickname = String(nickname);       if (car_plate) profile.car_plate = String(car_plate);     }     // mark verified for password users     profile.verified = true;     writeUserData(phone, 'profile.json', profile);      // ensure orders file exists     const ordersPath = getUserDataPath(phone, 'orders.json');     if (!fs.existsSync(ordersPath)) {       writeUserData(phone, 'orders.json', []);     }      // permissions flags     const permissions = {       role: finalRole,       can_access_admin: finalRole === 'admin',       can_access_driver: finalRole === 'driver' || finalRole === 'admin',       can_access_passenger: true     };      // sign JWT (HS256)     const jwtSecret = process.env.JWT_SECRET || process.env.EDGE_JWT_SECRET || 'dev_local_secret_change_this';     const now = Math.floor(Date.now() / 1000);     const exp = now + 60 * 60 * 24 * (remember ? 30 : 7);     const header = { alg: 'HS256', typ: 'JWT' };     const payload = { iss: 'black-feather-taxi', iat: now, exp, sub: String(phone), role: finalRole, name: finalName };     const b64url = (input) => Buffer.from(typeof input === 'string' ? input : JSON.stringify(input)).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');     const unsigned = `${b64url(header)}.${b64url(payload)}`;     const signature = crypto.createHmac('sha256', jwtSecret).update(unsigned).digest('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');     const token = `${unsigned}.${signature}`;      const userData = { token, userId: String(phone), phone: String(phone), name: finalName, role: finalRole, permissions };      // �&��xx使���&��!�9人��� upsert     try {       upsertUserToGlobal({ id: String(phone), phone: String(phone), password_hash: `${salt}:${hash}`, role: finalRole, name: finalName, created_at: new Date().toISOString(), remember_me: !!remember });       upsertProfileToGlobal({ user_id: String(phone), vehicle_info: profile.car_plate || null, rating_avg: profile.rating_avg || null, total_orders: 0, current_status: status, location: profile.location || null });     } catch (_) {}     return res.json({ success: true, data: userData, message: '註� `�Ɛ�`x���S��S��9�"��0' });   } catch (error) {     console.error('create order error', e);     return res.status(500).json({ success: false, message: '伺�S��"��R�誤' });   } });  // �&�容�ƥ名�aPOST /api/register // ��! /auth/register �:��R�a�}��� phone㬁password 並建�9使���&�!�" app.post('/api/register', (req, res) => {   try {     const { phone, password, name, role = 'passenger', nickname, car_plate, remember } = req.body || {};     if (!phone || !password) {       return res.status(400).json({ success: false, message: '缺��&要�位�aphone, password' });     }      // �ܲ止�!��!註� `     const authPath = getUserDataPath(phone, 'auth.json');     if (fs.existsSync(authPath)) {       return res.status(409).json({ success: false, message: '此�"x碼已註� `' });     }      // �&���!��!檢�x����&��xx���� / ���S0�9人����0     try {       const store = readGlobalStore();       const existsInUsers = Array.isArray(store.users) && store.users.some(u => String(u.phone) === String(phone));       const existsInProfiles = Array.isArray(store.profiles) && store.profiles.some(p => String(p.user_id) === String(phone));       const profilePath = getUserDataPath(phone, 'profile.json');       if (existsInUsers || existsInProfiles || fs.existsSync(profilePath)) {         return res.status(409).json({ success: false, message: '此�"x碼已註� `' });       }     } catch (_) {}      // �:S�`� 碼     const salt = crypto.randomBytes(16).toString('hex');     const hash = crypto.pbkdf2Sync(String(password), salt, 100000, 64, 'sha512').toString('hex');     writeUserData(phone, 'auth.json', { salt, hash, createdAt: new Date().toISOString() });      // 建�9�9人���     const finalRole = ['passenger','driver','admin'].includes(String(role)) ? String(role) : 'passenger';     const finalName = name && String(name).trim().length > 0 ? String(name).trim() : `User_${phone}`;     const status = finalRole === 'driver' ? 'online' : 'idle';     const profile = { phone, name: finalName, role: finalRole, status };     if (finalRole === 'driver') {       if (nickname) profile.nickname = String(nickname);       if (car_plate) profile.car_plate = String(car_plate);     }     profile.verified = true; // � 碼註� `�:��}��"��已��0     writeUserData(phone, 'profile.json', profile);      // 確保���������S�     const ordersPath = getUserDataPath(phone, 'orders.json');     if (!fs.existsSync(ordersPath)) {       writeUserData(phone, 'orders.json', []);     }      // �`�"���"     const permissions = {       role: finalRole,       can_access_admin: finalRole === 'admin',       can_access_driver: finalRole === 'driver' || finalRole === 'admin',       can_access_passenger: true     };      // 簽�"� JWT��HS256�0     const jwtSecret = process.env.JWT_SECRET || process.env.EDGE_JWT_SECRET || 'dev_local_secret_change_this';     const now = Math.floor(Date.now() / 1000);     const exp = now + 60 * 60 * 24 * (remember ? 30 : 7);     const header = { alg: 'HS256', typ: 'JWT' };     const payload = { iss: 'black-feather-taxi', iat: now, exp, sub: String(phone), role: finalRole, name: finalName };     const b64url = (input) => Buffer.from(typeof input === 'string' ? input : JSON.stringify(input)).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');     const unsigned = `${b64url(header)}.${b64url(payload)}`;     const signature = crypto.createHmac('sha256', jwtSecret).update(unsigned).digest('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');     const token = `${unsigned}.${signature}`;      const userData = { token, userId: String(phone), phone: String(phone), name: finalName, role: finalRole, permissions };      // �&��xx使���&��!�9人��� upsert     try {       upsertUserToGlobal({ id: String(phone), phone: String(phone), password_hash: `${salt}:${hash}`, role: finalRole, name: finalName, created_at: new Date().toISOString(), remember_me: !!remember });       upsertProfileToGlobal({ user_id: String(phone), vehicle_info: profile.car_plate || null, rating_avg: profile.rating_avg || null, total_orders: 0, current_status: status, location: profile.location || null });     } catch (_) {}     return res.json({ success: true, data: userData, message: '註� `�Ɛ�`x���S��S��9�"��0' });   } catch (error) {     console.error('create order error', e);     return res.status(500).json({ success: false, message: '伺�S��"��R�誤' });   } });  // Password-based login (local development) // POST /auth/login-pwd { phone, password, remember? } app.post('/auth/login-pwd', (req, res) => {   try {     const { phone, password, remember } = req.body || {};     if (!phone || !password) {       return res.status(400).json({ success: false, message: '缺��&要�位�aphone, password' });     }      // load auth info     const auth = readUserData(phone, 'auth.json', null);     if (!auth || !auth.salt || !auth.hash) {       return res.status(404).json({ success: false, message: '使���&不���S����a�S�設�a� 碼' });     }     const candidate = crypto.pbkdf2Sync(String(password), auth.salt, 100000, 64, 'sha512').toString('hex');     const isValid = candidate === auth.hash; // timingSafeEqual require Buffer length match; here hex strings fixed length     if (!isValid) {       return res.status(401).json({ success: false, message: '� 碼不正確' });     }      // profile     const profile = readUserData(phone, 'profile.json', {});     const finalRole = profile.role || 'passenger';     const finalName = profile.name || `User_${phone}`;     // permissions flags     const permissions = {       role: finalRole,       can_access_admin: finalRole === 'admin',       can_access_driver: finalRole === 'driver' || finalRole === 'admin',       can_access_passenger: true     };      // sign JWT (HS256)     const jwtSecret = process.env.JWT_SECRET || process.env.EDGE_JWT_SECRET || 'dev_local_secret_change_this';     const now = Math.floor(Date.now() / 1000);     const exp = now + 60 * 60 * 24 * (remember ? 30 : 7);     const header = { alg: 'HS256', typ: 'JWT' };     const payload = { iss: 'black-feather-taxi', iat: now, exp, sub: String(phone), role: finalRole, name: finalName };     const b64url = (input) => Buffer.from(typeof input === 'string' ? input : JSON.stringify(input)).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');     const unsigned = `${b64url(header)}.${b64url(payload)}`;     const signature = crypto.createHmac('sha256', jwtSecret).update(unsigned).digest('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');     const token = `${unsigned}.${signature}`;      const userData = { token, userId: String(phone), phone: String(phone), name: finalName, role: finalRole, permissions };      // �&��xx使���&��!�9人��� upsert��保�0���S��0     try {       upsertUserToGlobal({ id: String(phone), phone: String(phone), role: finalRole, name: finalName });       upsertProfileToGlobal({ user_id: String(phone), current_status: profile.status || 'idle', vehicle_info: profile.car_plate || null, rating_avg: profile.rating_avg || null, total_orders: profile.total_orders || 0, location: profile.location || null });     } catch (_) {}     return res.json({ success: true, data: userData, message: '�"��&��Ɛ�`x���S��S��9�"��0' });   } catch (error) {     console.error('create order error', e);     return res.status(500).json({ success: false, message: '伺�S��"��R�誤' });   } });  // �&�容�ƥ名�aPOST /api/login // ��! /auth/login-pwd �:��R�a��0 phone㬁password�R�Ɛ�`x�:~�� auth_token app.post('/api/login', (req, res) => {   try {     const { phone, password, remember } = req.body || {};     if (!phone || !password) {       return res.status(400).json({ success: false, message: '缺��&要�位�aphone, password' });     }      // 讬�� 碼�!�`     const auth = readUserData(phone, 'auth.json', null);     if (!auth || !auth.salt || !auth.hash) {       return res.status(404).json({ success: false, message: '帳�"x不���S�' });     }     const candidate = crypto.pbkdf2Sync(String(password), auth.salt, 100000, 64, 'sha512').toString('hex');     const isValid = candidate === auth.hash;     if (!isValid) {       return res.status(401).json({ success: false, message: '� 碼�R�誤' });     }      // ���使���&�!�"     const profile = readUserData(phone, 'profile.json', {});     const finalRole = profile.role || 'passenger';     const finalName = profile.name || `User_${phone}`;     const permissions = {       role: finalRole,       can_access_admin: finalRole === 'admin',       can_access_driver: finalRole === 'driver' || finalRole === 'admin',       can_access_passenger: true     };      // 簽�"� JWT��HS256�0     const jwtSecret = process.env.JWT_SECRET || process.env.EDGE_JWT_SECRET || 'dev_local_secret_change_this';     const now = Math.floor(Date.now() / 1000);     const exp = now + 60 * 60 * 24 * (remember ? 30 : 7);     const header = { alg: 'HS256', typ: 'JWT' };     const payload = { iss: 'black-feather-taxi', iat: now, exp, sub: String(phone), role: finalRole, name: finalName };     const b64url = (input) => Buffer.from(typeof input === 'string' ? input : JSON.stringify(input)).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');     const unsigned = `${b64url(header)}.${b64url(payload)}`;     const signature = crypto.createHmac('sha256', jwtSecret).update(unsigned).digest('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');     const token = `${unsigned}.${signature}`;      const userData = { token, userId: String(phone), phone: String(phone), name: finalName, role: finalRole, permissions };      // upsert �&��xx�!�"     try {       upsertUserToGlobal({ id: String(phone), phone: String(phone), role: finalRole, name: finalName });       upsertProfileToGlobal({ user_id: String(phone), current_status: profile.status || 'idle', vehicle_info: profile.car_plate || null, rating_avg: profile.rating_avg || null, total_orders: profile.total_orders || 0, location: profile.location || null });     } catch (_) {}     return res.json({ success: true, data: userData, message: '�"��&��Ɛ�`x���S��S��9�"��0' });   } catch (error) {     console.error('create order error', e);     return res.status(500).json({ success: false, message: '伺�S��"��R�誤' });   } });  // �0�端 fallback app.get('*', (req, res) => {   res.sendFile(path.join(__dirname, '../dist/index.html')); });  // Health endpoint // Health endpoint (with Airtable driver stats) app.get('/api/health', async (req, res) => {   try {     let stats = null;     try {       const all = await airtable('Drivers').select().all();       const total = all.length;       const idle = all.filter(d => (d.fields.status || '').toLowerCase() === 'available').length;       const busy = all.filter(d => (d.fields.status || '').toLowerCase() === 'on_trip').length;       const offline = all.filter(d => (d.fields.status || '').toLowerCase() === 'offline').length;       stats = { total, idle, busy, offline };     } catch (_) {       // Airtable ???,????????       stats = null;     }     res.json({ status: 'ok', data: stats });   } catch (err) {     res.status(500).json({ status: 'error', error: err?.message || 'unknown error' });   } });  server.listen(PORT, () => {   console.log(`[server] listening on http://localhost:${process.env.PORT || 3001}`);   console.log(`[env] PORT=${process.env.PORT || 3001}`);   console.log(`server started`);   // keep process alive (temporary workaround while we diagnose exit)   setInterval(() => {}, 1 << 30); });  export default app;   // �"��&����S��S��9�"��R援�0�a簽�"� HS256 JWT�R��! Edge phone-login 對�` app.post('/auth/login', (req, res) => {   try {     const { phone, role = 'passenger', name = '' } = req.body || {};     if (!phone) {       return res.status(400).json({ success: false, message: '缺��&要叒�"��aphone' });     }      // 檢�x��ܯ否已��0     const auth = readAuthState(phone);     if (!auth?.isVerified) {       return res.status(403).json({          success: false,          error: { code: 'USER_NOT_VERIFIED', message: '���ƶ�a�S��R�Ɛ�09�x��0' },         data: { verificationRequired: true }       });     }      // 建�9/�:���使���&�x��S��!�"     const profile = readUserData(phone, 'profile.json', {});     const finalRole = (role || profile.role || 'passenger');     const finalName = (name || profile.name || `���ƶ_${phone}`);     const newProfile = { ...profile, phone, role: finalRole, name: finalName, status: profile.status || (finalRole === 'driver' ? 'online' : 'idle') };     writeUserData(phone, 'profile.json', newProfile);      // �`�"���"����! Edge 對�`�0     const permissions = {       role: finalRole,       can_access_admin: finalRole === 'admin',       can_access_driver: finalRole === 'driver' || finalRole === 'admin',       can_access_passenger: true     };      // 簽�"� JWT��HS256�0     const jwtSecret = process.env.JWT_SECRET || process.env.EDGE_JWT_SECRET || 'dev_local_secret_change_this';     const now = Math.floor(Date.now() / 1000);     const exp = now + 60 * 60 * 24 * 7; // 7 天     const header = { alg: 'HS256', typ: 'JWT' };     const payload = {       iss: 'black-feather-taxi',       iat: now,       exp,       sub: String(phone),       role: finalRole,       name: finalName     };     const b64url = (input) => Buffer.from(typeof input === 'string' ? input : JSON.stringify(input))       .toString('base64')       .replace(/\+/g, '-')       .replace(/\//g, '_')       .replace(/=+$/g, '');     const unsigned = `${b64url(header)}.${b64url(payload)}`;     const signature = crypto.createHmac('sha256', jwtSecret).update(unsigned).digest('base64')       .replace(/\+/g, '-')       .replace(/\//g, '_')       .replace(/=+$/g, '');     const token = `${unsigned}.${signature}`;      const userData = {       token,       userId: phone,       phone,       name: finalName,       role: finalRole,       permissions     };      return res.json({ success: true, data: userData, message: '�"��&��Ɛ�`x���S��S��9�"��0' });   } catch (error) {     console.error('create order error', e);     return res.status(500).json({ success: false, message: '伺�S��"��R�誤' });   } });       